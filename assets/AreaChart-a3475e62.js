import{j as t,a as $,F as J}from"./jsx-runtime-86dfebf6.js";import{r}from"./index-1b03fe98.js";import{c as pe}from"./index-256d607f.js";import{C as S}from"./rdk-0beed5d4.js";import{a as me,b as ce}from"./ScatterPlot-34d242f9.js";import{l as fe,D as te,M as re,G as ye,T as ne,b as he,f as Ve,h as Pe}from"./schemes-56affe43.js";import{p as Ce,M as Se,j as be,g as ve,L as ge,b as ke,G as qe}from"./RadialValueMarker-7b3f8322.js";import{i as le}from"./interpolation-4baac368.js";import{c as ie,i as K}from"./functions-234b1417.js";import{g as oe}from"./utils-83ce1bd4.js";import{a as Ae}from"./area-a8b9ef93.js";import{d as xe}from"./RadialAxis-6c2bc59c.js";import{g as _e}from"./helper-26bacd48.js";import{i as Q}from"./index-9494de61.js";import{f as H}from"./range-163cdb4a.js";import{g as Le,n as Te,c as De,b as Fe,a as Me}from"./builder-9833ba7e.js";import{u as we}from"./chroma-699b8ba0.js";import{s as ee,a as Ee}from"./expand-7b65a05b.js";function Ne(e,a){const i=a.indexOf(e);let l=!1;const s=a[i-1];i>0&&s.y&&(l=!0),a[i].y&&(l=!0);const o=a[i+1];return i<a.length-1&&o.y&&(l=!0),l}function Re(e){const a=[],i=Le(e);for(const l of e)for(const s of l.data){let b=a.findIndex(o=>o.x instanceof Date&&s.key instanceof Date?o.x.getTime()===s.key.getTime():o.x===s.key);b===-1&&(a.push({x:s.key,formattedValues:{}}),b=a.length-1),a[b][l.key]=Te(s.data,i),a[b].formattedValues[l.key]=De(s.data)}return a}function Ie(e){const a=[];for(const i of e){const l=[];for(const s of i){const[b,o]=s,h=s.data.x;l.push({key:i.key,x:h,x0:h,x1:h,y:o-b,y0:b,y1:o,value:s.data.formattedValues[i.key]})}a.push({key:i.key,data:l})}return a}function $e(e,a=!1){const i=we(e,o=>o.key),l=Re(e),b=(a?ee().offset(Ee):ee()).keys(i)(l);return Ie(b)}const Ge="_point_u68jv_1",ze={point:Ge},X=({data:e,xScale:a,yScale:i,animated:l,point:s,color:b,height:o,width:h,id:V,activeValues:d,show:C})=>{const A=r.useCallback((m,v)=>{const x=d&&m&&fe(d.x,m.x);return C==="hover"?x:C==="first"?d?x:v===0:C==="last"?d?x:v===e.length-1:C},[d,e.length,C]);return t(me,{height:o,width:h,id:V,animated:l,data:e,xScale:a,yScale:i,point:t(S,{element:s,color:b,className:ze.point,size:4,tooltip:null,visible:A})})};X.defaultProps={show:"hover",point:t(ce,{})};try{X.displayName="PointSeries",X.__docgenInfo={description:"",displayName:"PointSeries",props:{animated:{defaultValue:null,description:"Determines if the points should be animated or not.",name:"animated",required:!1,type:{name:"boolean"}},color:{defaultValue:null,description:"The color of the points.",name:"color",required:!1,type:{name:"any"}},activeValues:{defaultValue:null,description:"The active values for the points.",name:"activeValues",required:!1,type:{name:"any"}},data:{defaultValue:null,description:"The data for the points.",name:"data",required:!1,type:{name:"ChartInternalShallowDataShape[]"}},yScale:{defaultValue:null,description:"The y-scale for the points.",name:"yScale",required:!1,type:{name:"any"}},xScale:{defaultValue:null,description:"The x-scale for the points.",name:"xScale",required:!1,type:{name:"any"}},id:{defaultValue:null,description:"The unique identifier for the points.",name:"id",required:!1,type:{name:"string"}},height:{defaultValue:null,description:"The height of the points.",name:"height",required:!1,type:{name:"number"}},width:{defaultValue:null,description:"The width of the points.",name:"width",required:!1,type:{name:"number"}},show:{defaultValue:{value:"hover"},description:"Determines when the points should be shown. Can be a boolean or one of the following strings: 'hover', 'first', 'last'.",name:"show",required:!1,type:{name:'boolean | "hover" | "first" | "last"'}},point:{defaultValue:{value:"<ScatterPoint />"},description:"The point element.",name:"point",required:!1,type:{name:"ReactElement<ScatterPointProps, FC<Partial<ScatterPointProps>>>"}},index:{defaultValue:null,description:"The index of the points.",name:"index",required:!1,type:{name:"number"}}}}}catch{}const Y=({id:e,gradient:a,glow:i,mask:l,data:s,color:b,index:o,total:h,xScale:V,yScale:d,animated:C,interpolation:A,...m})=>{const v=b(s,o),x=r.useMemo(()=>s.map(u=>({x:V(u.x),x1:V(u.x)-V(u.x1),y:d(u.y),y0:d(u.y0),y1:d(u.y1)})),[s,V,d]),c=r.useCallback(u=>{if(u.length===1&&h===1){const[p]=u,g=p.x;u=[{...p},{...p}];const[E,k]=u;E.x=0,k.x=g*2}return Ae().x(p=>p.x).y0(p=>p.y0).y1(p=>p.y1).curve(le(A))(u)},[A,h]),L=r.useMemo(()=>{const u=c(x);return{d:u===null?void 0:u}},[x,c]),_=r.useMemo(()=>{const u=Math.max(...d.range()),D=s.map(g=>({x:V(g.x),x1:0,y:0,y1:u,y0:u})),p=c(D);return{d:p===null?void 0:p}},[s,c,V,d]),T=r.useMemo(()=>l?`url(#mask-pattern-${e})`:a?`url(#gradient-${e})`:"",[a,e,l]),R=r.useMemo(()=>C?{...te,delay:o*.05}:{type:!1,delay:0},[C,o]),M=r.useCallback(()=>{const u=l?`url(#mask-${e})`:"",D=ie(m,s);return t(re,{...D,pointerEvents:"none",mask:u,fill:T,transition:R,custom:{enter:L,exit:_},style:{...D.style,...oe({glow:i,colorSchemeColor:v})}})},[s,L,_,T,i,e,l,m,v,R]);return $(r.Fragment,{children:[M(),l&&$(r.Fragment,{children:[t(Ce,{id:`mask-${e}`,fill:`url(#gradient-${e})`}),t(S,{element:l,id:`mask-pattern-${e}`,fill:v})]}),a&&t(S,{element:a,id:`gradient-${e}`,color:v})]})};Y.defaultProps={gradient:t(ye,{}),interpolation:"linear"};try{Y.displayName="Area",Y.__docgenInfo={description:"",displayName:"Area",props:{id:{defaultValue:null,description:"Id set internally by `AreaSeries`.",name:"id",required:!1,type:{name:"string"}},data:{defaultValue:null,description:"Parsed data shape. Set internally by `AreaChart`.",name:"data",required:!1,type:{name:"ChartInternalDataShape[]"}},interpolation:{defaultValue:{value:"linear"},description:"Interpolation for the area. Set internally by `AreaSeries`.",name:"interpolation",required:!1,type:{name:"enum",value:[{value:'"linear"'},{value:'"smooth"'},{value:'"step"'}]}},color:{defaultValue:null,description:"Color for the area. Set internally by `AreaSeries`.",name:"color",required:!1,type:{name:"any"}},xScale:{defaultValue:null,description:"D3 scale for X Axis. Set internally by `AreaChart`.",name:"xScale",required:!1,type:{name:"any"}},yScale:{defaultValue:null,description:"D3 scale for Y Axis. Set internally by `AreaChart`.",name:"yScale",required:!1,type:{name:"any"}},index:{defaultValue:null,description:"Index of the area in the series. Set internally by `AreaSeries`.",name:"index",required:!1,type:{name:"number"}},total:{defaultValue:null,description:"Total number of areas in the series. Set internally by `AreaSeries`.",name:"total",required:!1,type:{name:"number"}},animated:{defaultValue:null,description:"Whether to animate the enter/update/exit. Set internally by `AreaSeries`.",name:"animated",required:!1,type:{name:"boolean"}},mask:{defaultValue:null,description:"Mask to apply to the area.",name:"mask",required:!1,type:{name:"ReactElement<MaskProps, FC<MaskProps>>"}},gradient:{defaultValue:{value:"<Gradient />"},description:"Gradient to apply to the area.",name:"gradient",required:!1,type:{name:"ReactElement<GradientProps, FC<Partial<GradientProps>>>"}},glow:{defaultValue:null,description:"Glow to apply to the area.",name:"glow",required:!1,type:{name:"Glow"}},className:{defaultValue:null,description:"Classnames to apply to the element.",name:"className",required:!1,type:{name:"any"}},style:{defaultValue:null,description:"CSS styles to apply to the element.",name:"style",required:!1,type:{name:"any"}}}}}catch{}const Z=({id:e,width:a,data:i,color:l,index:s,strokeWidth:b,hasArea:o,animated:h,yScale:V,xScale:d,showZeroStroke:C,interpolation:A,gradient:m,glow:v,...x})=>{const[c,L]=r.useState(null),_=r.useRef(null);r.useEffect(()=>{_.current&&L(_.current.getTotalLength())},[i,d,V,a]);const T=r.useCallback(f=>xe().x(w=>w.x).y(w=>w.y1).defined(w=>C||Ne(w,f)).curve(le(A))(f),[A,C]),R=r.useMemo(()=>h?{...te,delay:o?0:s*.05}:{type:!1,delay:0},[h,o,s]),M=r.useMemo(()=>i.map(f=>({x:d(f.x),x1:d(f.x)-d(f.x1),y:V(f.y),y0:V(f.y0),y1:V(f.y1)})),[i,d,V]),u=r.useMemo(()=>{const f=T(M);let N="";return!o&&c!==null&&(N=`${c} ${c}`),{d:f===null?void 0:f,strokeDashoffset:0,strokeDasharray:N}},[M,T,o,c]),D=r.useMemo(()=>{let f=M;if(o){const n=Math.max(...V.range());f=i.map(y=>({x:d(y.x),x1:0,y:n,y1:n,y0:n}))}const N=T(f);let w="",P=0;return!o&&c!==null&&(w=`${c} ${c}`,P=c),{d:N===null?void 0:N,strokeDasharray:w,strokeDashoffset:P}},[M,i,T,o,c,d,V]),p=l(i,s),g=ie(x,i),E=o||c!==null,k=r.useMemo(()=>m?`url(#gradient-${e})`:p,[m,e]);return o&&(delete u.strokeDashoffset,delete D.strokeDashoffset),$(r.Fragment,{children:[E&&t(re,{...g,pointerEvents:"none",stroke:k,strokeWidth:b,fill:"none",transition:R,custom:{enter:u,exit:D},style:{...g.style,...oe({glow:v,colorSchemeColor:k})}}),!o&&t("path",{opacity:"0",d:u.d,ref:_,pointerEvents:"none"}),m&&t(S,{element:m,id:`gradient-${e}`,color:p})]})};Z.defaultProps={showZeroStroke:!0,strokeWidth:3};try{Z.displayName="Line",Z.__docgenInfo={description:"",displayName:"Line",props:{id:{defaultValue:null,description:"Id set internally by `AreaChart`.",name:"id",required:!1,type:{name:"string"}},data:{defaultValue:null,description:"Parsed data shape. Set internally by `AreaChart`.",name:"data",required:!1,type:{name:"ChartInternalDataShape[]"}},width:{defaultValue:null,description:"Width of the chart. Set internally by `AreaChart`.",name:"width",required:!1,type:{name:"number"}},interpolation:{defaultValue:null,description:"Interpolation for the area. Set internally by `AreaSeries`.",name:"interpolation",required:!1,type:{name:"enum",value:[{value:'"linear"'},{value:'"smooth"'},{value:'"step"'}]}},color:{defaultValue:null,description:"Color for the area. Set internally by `AreaSeries`.",name:"color",required:!1,type:{name:"any"}},xScale:{defaultValue:null,description:"D3 scale for X Axis. Set internally by `AreaChart`.",name:"xScale",required:!1,type:{name:"any"}},yScale:{defaultValue:null,description:"D3 scale for Y Axis. Set internally by `AreaChart`.",name:"yScale",required:!1,type:{name:"any"}},index:{defaultValue:null,description:"Index of the area in the series. Set internally by `AreaSeries`.",name:"index",required:!1,type:{name:"number"}},animated:{defaultValue:null,description:"Whether to animate the enter/update/exit. Set internally by `AreaSeries`.",name:"animated",required:!1,type:{name:"boolean"}},strokeWidth:{defaultValue:{value:"3"},description:"Stroke width of the line.",name:"strokeWidth",required:!1,type:{name:"number"}},showZeroStroke:{defaultValue:{value:"true"},description:"Show the stroke if there is no value.",name:"showZeroStroke",required:!1,type:{name:"boolean"}},hasArea:{defaultValue:null,description:"Internal property to identify if there is a area or not.",name:"hasArea",required:!1,type:{name:"boolean"}},gradient:{defaultValue:null,description:"Gradient to apply to the line.",name:"gradient",required:!1,type:{name:"ReactElement<GradientProps, FC<Partial<GradientProps>>>"}},glow:{defaultValue:null,description:"Glow to apply to the line.",name:"glow",required:!1,type:{name:"Glow"}},className:{defaultValue:null,description:"Classnames to apply to the element.",name:"className",required:!1,type:{name:"any"}},style:{defaultValue:null,description:"CSS styles to apply to the element.",name:"style",required:!1,type:{name:"any"}}}}}catch{}const j=25,ae=j/2,G=({data:e,height:a,id:i,width:l,isZoomed:s,tooltip:b,xScale:o,yScale:h,type:V,markLine:d,symbols:C,animated:A,area:m,interpolation:v,line:x,colorScheme:c,valueMarkers:L})=>{const[_,T]=r.useState(null),[R,M]=r.useState(null),u=r.useCallback(n=>{M(n.pointX),T(n.value)},[]),D=r.useCallback(()=>{M(void 0),T(void 0)},[]),p=V==="grouped"||V==="stacked"||V==="stackedNormalized",g=r.useCallback((n,y)=>{var F;const q=Array.isArray(n)?(F=n==null?void 0:n[0])==null?void 0:F.key:n==null?void 0:n.key;return _e({data:e,colorScheme:c,active:_,point:n,index:y,key:q})},[_,c,e]),E=r.useCallback((n,y=0,q=1)=>$(r.Fragment,{children:[x&&t(S,{element:x,xScale:o,yScale:h,data:n,width:l,index:y,hasArea:m!==null,animated:A,interpolation:v,color:g}),m&&t(S,{element:m,id:`${i}-area-${y}`,xScale:o,yScale:h,data:n,index:y,total:q,animated:A,interpolation:v,color:g})]}),[A,m,g,i,v,x,l,o,h]),k=r.useCallback((n,y=0)=>{const q=C!==null,F=C&&C.props.activeValues||_,I=m!==void 0&&A&&!F;return t(r.Fragment,{children:q&&t(S,{element:C,id:i,height:a,width:l,activeValues:F,xScale:o,yScale:h,index:y,data:n,animated:I,color:()=>g(n,y)},`point-series-${i}`)})},[_,A,m,g,a,i,C,l,o,h]),f=r.useCallback(()=>t(J,{children:_&&d&&t(S,{element:d,height:a,pointX:R})}),[R,_,a,d]),N=r.useCallback(n=>$(r.Fragment,{children:[E(n),f(),k(n)]}),[E,f,k]),w=r.useCallback(n=>$(r.Fragment,{children:[n.map((y,q)=>t(r.Fragment,{children:E(y.data,q,n.length)},Q(`${y.key}`))).reverse(),f(),n.map((y,q)=>t(r.Fragment,{children:k(y.data,q)},Q(`${y.key}`))).reverse()]}),[E,f,k]),P=r.useCallback(()=>t(J,{children:(L==null?void 0:L.length)&&L.map(n=>{var I;const y=((I=n==null?void 0:n.props)==null?void 0:I.direction)==="vertical",q=y?a:l,F=y?o(n.props.value):h(n.props.value);return t(S,{element:n,size:q,value:F},n.key)})}),[L,l,h]);return $(r.Fragment,{children:[t("defs",{children:t("clipPath",{id:`${i}-path`,children:t("rect",{width:s?l:l+j,height:a+j,x:s?0:-ae,y:-ae})})}),t(S,{element:b,xScale:o,yScale:h,data:e,height:a,width:l,color:g,onValueEnter:u,onValueLeave:D,children:$("g",{clipPath:`url(#${i}-path)`,children:[p&&w(e),!p&&N(e),P()]})})]})};G.defaultProps={colorScheme:"cybertron",animated:!0,interpolation:"linear",type:"standard",line:t(Z,{}),area:t(Y,{}),markLine:t(Se,{}),tooltip:t(ne,{}),symbols:t(X,{})};try{G.displayName="AreaSeries",G.__docgenInfo={description:"",displayName:"AreaSeries",props:{id:{defaultValue:null,description:"Id set internally by `AreaChart`.",name:"id",required:!1,type:{name:"string"}},xScale:{defaultValue:null,description:"D3 scale for X Axis. Set internally by `AreaChart`.",name:"xScale",required:!1,type:{name:"any"}},yScale:{defaultValue:null,description:"D3 scale for Y Axis. Set internally by `AreaChart`.",name:"yScale",required:!1,type:{name:"any"}},data:{defaultValue:null,description:"Parsed data shape. Set internally by `AreaChart`.",name:"data",required:!1,type:{name:"ChartInternalDataShape[]"}},height:{defaultValue:null,description:"Height of the chart. Set internally by `AreaChart`.",name:"height",required:!1,type:{name:"number"}},width:{defaultValue:null,description:"Width of the chart. Set internally by `AreaChart`.",name:"width",required:!1,type:{name:"number"}},animated:{defaultValue:{value:"true"},description:"Whether to animate the enter/update/exit.",name:"animated",required:!1,type:{name:"boolean"}},type:{defaultValue:{value:"standard"},description:"Type of area chart to render.",name:"type",required:!1,type:{name:"enum",value:[{value:'"standard"'},{value:'"grouped"'},{value:'"stacked"'},{value:'"stackedNormalized"'}]}},interpolation:{defaultValue:{value:"linear"},description:"Interpolation type for the area/line.",name:"interpolation",required:!1,type:{name:"enum",value:[{value:'"linear"'},{value:'"smooth"'},{value:'"step"'}]}},tooltip:{defaultValue:{value:"<TooltipArea />"},description:"Tooltip for the chart area.",name:"tooltip",required:!1,type:{name:"ReactElement<TooltipAreaProps, ForwardRefExoticComponent<Partial<TooltipAreaProps> & RefAttributes<any>>>"}},markLine:{defaultValue:{value:"<MarkLine />"},description:"Markline for the chart.",name:"markLine",required:!1,type:{name:"ReactElement<MarkLineProps, FC<Partial<MarkLineProps>>>"}},symbols:{defaultValue:{value:"<PointSeries />"},description:"Symbols used to show points.",name:"symbols",required:!1,type:{name:"ReactElement<PointSeriesProps, FC<Partial<PointSeriesProps>>>"}},line:{defaultValue:{value:"<Line />"},description:"Line that is rendered.",name:"line",required:!1,type:{name:"ReactElement<LineProps, FC<Partial<LineProps>>>"}},area:{defaultValue:{value:"<Area />"},description:"Area that is rendered.",name:"area",required:!1,type:{name:"ReactElement<AreaProps, FC<Partial<AreaProps>>>"}},colorScheme:{defaultValue:{value:"cybertron"},description:"Color scheme for the series.",name:"colorScheme",required:!1,type:{name:"ColorSchemeType"}},isZoomed:{defaultValue:null,description:"Whether the chart has been zoomed or not. Set internally by `AreaChart`.",name:"isZoomed",required:!1,type:{name:"boolean"}},valueMarkers:{defaultValue:null,description:"Value markers line for the chart.",name:"valueMarkers",required:!1,type:{name:"ReactElement<LinearValueMarkerProps, FC<LinearValueMarkerProps>>[]"}}}}}catch{}const B=({type:e,symbols:a,...i})=>t(G,{...i,type:"stackedNormalized",symbols:a&&t(S,{element:a,...a.props,point:t(S,{element:a.props.point,...a.props.point.props,tooltip:null})})});B.defaultProps={...G.defaultProps,type:"stackedNormalized",tooltip:t(ne,{tooltip:t(he,{content:(e,a)=>{if(!e)return null;const i={...e,data:e.data.map(l=>({...l,value:`${H(l.value)} ∙ ${H(Math.floor((l.y1-l.y0)*100))}%`}))};return t(Ve,{color:a,value:i})}})})};try{B.displayName="StackedNormalizedAreaSeries",B.__docgenInfo={description:"",displayName:"StackedNormalizedAreaSeries",props:{id:{defaultValue:null,description:"Id set internally by `AreaChart`.",name:"id",required:!1,type:{name:"string"}},xScale:{defaultValue:null,description:"D3 scale for X Axis. Set internally by `AreaChart`.",name:"xScale",required:!1,type:{name:"any"}},yScale:{defaultValue:null,description:"D3 scale for Y Axis. Set internally by `AreaChart`.",name:"yScale",required:!1,type:{name:"any"}},data:{defaultValue:null,description:"Parsed data shape. Set internally by `AreaChart`.",name:"data",required:!1,type:{name:"ChartInternalDataShape[]"}},height:{defaultValue:null,description:"Height of the chart. Set internally by `AreaChart`.",name:"height",required:!1,type:{name:"number"}},width:{defaultValue:null,description:"Width of the chart. Set internally by `AreaChart`.",name:"width",required:!1,type:{name:"number"}},animated:{defaultValue:null,description:"Whether to animate the enter/update/exit.",name:"animated",required:!1,type:{name:"boolean"}},type:{defaultValue:{value:"stackedNormalized"},description:"Type of area chart to render.",name:"type",required:!1,type:{name:"enum",value:[{value:'"standard"'},{value:'"grouped"'},{value:'"stacked"'},{value:'"stackedNormalized"'}]}},interpolation:{defaultValue:null,description:"Interpolation type for the area/line.",name:"interpolation",required:!1,type:{name:"enum",value:[{value:'"linear"'},{value:'"smooth"'},{value:'"step"'}]}},tooltip:{defaultValue:{value:`(
    <TooltipArea
      tooltip={
        <ChartTooltip
          content={(series, color) => {
            if (!series) {
              return null;
            }

            const value = {
              ...series,
              data: series.data.map((d) => ({
                ...d,
                value: \`\${formatValue(d.value)} ∙ \${formatValue(
                  Math.floor((d.y1 - d.y0) * 100)
                )}%\`
              }))
            };

            return <TooltipTemplate color={color} value={value} />;
          }}
        />
      }
    />
  )`},description:"Tooltip for the chart area.",name:"tooltip",required:!1,type:{name:"ReactElement<TooltipAreaProps, ForwardRefExoticComponent<Partial<TooltipAreaProps> & RefAttributes<any>>>"}},markLine:{defaultValue:null,description:"Markline for the chart.",name:"markLine",required:!1,type:{name:"ReactElement<MarkLineProps, FC<Partial<MarkLineProps>>>"}},symbols:{defaultValue:null,description:"Symbols used to show points.",name:"symbols",required:!1,type:{name:"ReactElement<PointSeriesProps, FC<Partial<PointSeriesProps>>>"}},line:{defaultValue:null,description:"Line that is rendered.",name:"line",required:!1,type:{name:"ReactElement<LineProps, FC<Partial<LineProps>>>"}},area:{defaultValue:null,description:"Area that is rendered.",name:"area",required:!1,type:{name:"ReactElement<AreaProps, FC<Partial<AreaProps>>>"}},colorScheme:{defaultValue:null,description:"Color scheme for the series.",name:"colorScheme",required:!1,type:{name:"ColorSchemeType"}},isZoomed:{defaultValue:null,description:"Whether the chart has been zoomed or not. Set internally by `AreaChart`.",name:"isZoomed",required:!1,type:{name:"boolean"}},valueMarkers:{defaultValue:null,description:"Value markers line for the chart.",name:"valueMarkers",required:!1,type:{name:"ReactElement<LinearValueMarkerProps, FC<LinearValueMarkerProps>>[]"}}}}}catch{}const U=({type:e,symbols:a,...i})=>t(G,{...i,type:"stacked",symbols:a&&t(S,{element:a,...a.props,point:t(S,{element:a.props.point,...a.props.point.props,tooltip:null})})});U.defaultProps={...G.defaultProps,type:"stacked"};try{U.displayName="StackedAreaSeries",U.__docgenInfo={description:"",displayName:"StackedAreaSeries",props:{id:{defaultValue:null,description:"Id set internally by `AreaChart`.",name:"id",required:!1,type:{name:"string"}},xScale:{defaultValue:null,description:"D3 scale for X Axis. Set internally by `AreaChart`.",name:"xScale",required:!1,type:{name:"any"}},yScale:{defaultValue:null,description:"D3 scale for Y Axis. Set internally by `AreaChart`.",name:"yScale",required:!1,type:{name:"any"}},data:{defaultValue:null,description:"Parsed data shape. Set internally by `AreaChart`.",name:"data",required:!1,type:{name:"ChartInternalDataShape[]"}},height:{defaultValue:null,description:"Height of the chart. Set internally by `AreaChart`.",name:"height",required:!1,type:{name:"number"}},width:{defaultValue:null,description:"Width of the chart. Set internally by `AreaChart`.",name:"width",required:!1,type:{name:"number"}},animated:{defaultValue:null,description:"Whether to animate the enter/update/exit.",name:"animated",required:!1,type:{name:"boolean"}},type:{defaultValue:{value:"stacked"},description:"Type of area chart to render.",name:"type",required:!1,type:{name:"enum",value:[{value:'"standard"'},{value:'"grouped"'},{value:'"stacked"'},{value:'"stackedNormalized"'}]}},interpolation:{defaultValue:null,description:"Interpolation type for the area/line.",name:"interpolation",required:!1,type:{name:"enum",value:[{value:'"linear"'},{value:'"smooth"'},{value:'"step"'}]}},tooltip:{defaultValue:null,description:"Tooltip for the chart area.",name:"tooltip",required:!1,type:{name:"ReactElement<TooltipAreaProps, ForwardRefExoticComponent<Partial<TooltipAreaProps> & RefAttributes<any>>>"}},markLine:{defaultValue:null,description:"Markline for the chart.",name:"markLine",required:!1,type:{name:"ReactElement<MarkLineProps, FC<Partial<MarkLineProps>>>"}},symbols:{defaultValue:null,description:"Symbols used to show points.",name:"symbols",required:!1,type:{name:"ReactElement<PointSeriesProps, FC<Partial<PointSeriesProps>>>"}},line:{defaultValue:null,description:"Line that is rendered.",name:"line",required:!1,type:{name:"ReactElement<LineProps, FC<Partial<LineProps>>>"}},area:{defaultValue:null,description:"Area that is rendered.",name:"area",required:!1,type:{name:"ReactElement<AreaProps, FC<Partial<AreaProps>>>"}},colorScheme:{defaultValue:null,description:"Color scheme for the series.",name:"colorScheme",required:!1,type:{name:"ColorSchemeType"}},isZoomed:{defaultValue:null,description:"Whether the chart has been zoomed or not. Set internally by `AreaChart`.",name:"isZoomed",required:!1,type:{name:"boolean"}},valueMarkers:{defaultValue:null,description:"Value markers line for the chart.",name:"valueMarkers",required:!1,type:{name:"ReactElement<LinearValueMarkerProps, FC<LinearValueMarkerProps>>[]"}}}}}catch{}const Xe="_areaChart_yyojn_1",Ye={areaChart:Xe},O=({xAxis:e,yAxis:a,id:i,data:l,width:s,height:b,margins:o,className:h,containerClassName:V,series:d,gridlines:C,brush:A,zoomPan:m,secondaryAxis:v})=>{const x=m?m.props:{},[c,L]=r.useState(x.domain),[_,T]=r.useState(!1),[R,M]=r.useState(!!x.domain),[u]=r.useState(!x.hasOwnProperty("domain")),D=r.useRef(null),p=d.props.type,g=p==="stacked"||p==="stackedNormalized"||p==="grouped",E=_===!0?!1:d.props.animated;r.useEffect(()=>{if(m){const P=m.props;!u&&P.domain!==c&&(L(P.domain),M(!!P.domain))}},[u,c,m]);const k=r.useMemo(()=>p==="stacked"||p==="stackedNormalized"?$e(l,p==="stackedNormalized"):p==="grouped"?Fe(l,!0):Me(l),[l,p]),f=r.useCallback((P,n)=>{const y=be({width:P,type:e.props.type,roundDomains:e.props.roundDomains,data:k,domain:c||e.props.domain,isMultiSeries:g}),q=ve({roundDomains:a.props.roundDomains,type:a.props.type,height:n,data:k,domain:a.props.domain,isMultiSeries:g});return{xScale:y,yScale:q}},[k,g,e.props.domain,e.props.roundDomains,e.props.type,a.props.domain,a.props.roundDomains,a.props.type,c]),N=r.useCallback(P=>{u&&(L(P.domain),M(P.isZoomed),T(!0),clearTimeout(D.current),D.current=setTimeout(()=>T(!1)))},[u]),w=r.useCallback(({chartHeight:P,chartWidth:n,id:y,updateAxes:q,chartSized:F})=>{const{xScale:I,yScale:W}=f(n,P),se=k.length<=1;return $(r.Fragment,{children:[F&&C&&t(S,{element:C,height:P,width:n,yScale:W,xScale:I,yAxis:a.props,xAxis:e.props}),t(S,{element:e,height:P,width:n,scale:I,visibility:F?"visible":"hidden",onDimensionsChange:z=>q("horizontal",z)}),t(S,{element:a,height:P,width:n,scale:W,visibility:F?"visible":"hidden",onDimensionsChange:z=>q("vertical",z)}),v&&v.map((z,ue)=>t(S,{element:z,height:P,width:n,visibility:F?"visible":"hidden",onDimensionsChange:de=>q("horizontal",de)},ue)),F&&t(S,{disabled:se,element:A,height:P,width:n,scale:I,children:t(S,{element:m,onZoomPan:N,height:P,width:n,axisType:e.props.type,roundDomains:e.props.roundDomains,data:k,domain:c,children:t(S,{element:d,id:`area-series-${y}`,data:k,height:P,width:n,yScale:W,xScale:I,isZoomed:R,animated:E})})})]})},[k,E,A,f,C,R,N,v,d,e,a,c,m]);return t(Pe,{id:i,width:s,height:b,margins:o,containerClassName:V,xAxisVisible:K(e.props),yAxisVisible:K(a.props),className:pe(Ye.areaChart,h,d.type),children:w})};O.defaultProps={data:[],xAxis:t(ge,{type:"time"}),yAxis:t(ke,{type:"value"}),series:t(G,{}),gridlines:t(qe,{}),brush:null,zoomPan:null};try{O.displayName="AreaChart",O.__docgenInfo={description:"",displayName:"AreaChart",props:{data:{defaultValue:{value:"[]"},description:"Data the chart will receive to render.",name:"data",required:!1,type:{name:"ChartDataShape[]"}},series:{defaultValue:{value:"<AreaSeries />"},description:"The series component that renders the area/line/circles components.",name:"series",required:!1,type:{name:"ReactElement<AreaSeriesProps, FC<Partial<AreaSeriesProps>>>"}},yAxis:{defaultValue:{value:'<LinearYAxis type="value" />'},description:"The linear axis component for the Y Axis of the chart.",name:"yAxis",required:!1,type:{name:"ReactElement<LinearAxisProps, FC<Partial<LinearAxisProps>>>"}},xAxis:{defaultValue:{value:'<LinearXAxis type="time" />'},description:"The linear axis component for the X Axis of the chart.",name:"xAxis",required:!1,type:{name:"ReactElement<LinearAxisProps, FC<Partial<LinearAxisProps>>>"}},gridlines:{defaultValue:{value:"<GridlineSeries />"},description:"The chart's background gridlines component.",name:"gridlines",required:!1,type:{name:"ReactElement<GridlineSeriesProps, FC<Partial<GridlineSeriesProps>>>"}},brush:{defaultValue:{value:"null"},description:"The chart's brush component.",name:"brush",required:!1,type:{name:"ReactElement<ChartBrushProps, FC<Partial<ChartBrushProps>>>"}},zoomPan:{defaultValue:{value:"null"},description:"The chart's zoom pan component.",name:"zoomPan",required:!1,type:{name:"ReactElement<ChartZoomPanProps, FC<Partial<ChartZoomPanProps>>>"}},secondaryAxis:{defaultValue:null,description:"Any secondary axis components. Useful for multi-axis charts.",name:"secondaryAxis",required:!1,type:{name:"ReactElement<LinearAxisProps, FC<Partial<LinearAxisProps>>>[]"}},id:{defaultValue:null,description:"Id of the chart.",name:"id",required:!1,type:{name:"string"}},width:{defaultValue:null,description:"Width of the chart. If not provided will autosize.",name:"width",required:!1,type:{name:"number"}},height:{defaultValue:null,description:"Height of the chart. If not provided will autosize.",name:"height",required:!1,type:{name:"number"}},margins:{defaultValue:null,description:"Margins for the chart.",name:"margins",required:!1,type:{name:"Margins"}},className:{defaultValue:null,description:"Classnames for the chart.",name:"className",required:!1,type:{name:"string"}},containerClassName:{defaultValue:null,description:"Classnames for the chart.",name:"containerClassName",required:!1,type:{name:"string"}},style:{defaultValue:null,description:"Additional css styles.",name:"style",required:!1,type:{name:"StyleHTMLAttributes<SVGSVGElement>"}},center:{defaultValue:null,description:"Center the chart. Used mainly internally.",name:"center",required:!1,type:{name:"boolean"}},centerX:{defaultValue:null,description:"Center chart on X Axis only. Used mainly internally.",name:"centerX",required:!1,type:{name:"boolean"}},centerY:{defaultValue:null,description:"Center chart on Y Axis only. Used mainly internally.",name:"centerY",required:!1,type:{name:"boolean"}}}}}catch{}export{O as A,Z as L,X as P,U as S,G as a,Y as b,B as c};
